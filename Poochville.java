/*	Simple Swing based interactive dog	Click and it will move to that point	Drag and it will follow		It's moving on a surface that is inclined from the screen so it get's smaller "front to back"	bottom of frame is closer than top		Uses a set of image files for dog facing at angles around the circle	Load those in and generate scaled versions*/import java.awt.Color;import java.awt.Point;import java.awt.Image;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseAdapter;import java.awt.event.MouseMotionAdapter;import java.awt.event.MouseEvent;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.ImageIcon;import javax.swing.Timer;public class Poochville{	JFrame frame = null;	JLabel label = null;		String imageFilePrefix = "FooDog";	String imageFileSuffix = ".GIF";	int numImages = 8;		int zSteps = 10;		ImageIcon[][] images = new ImageIcon[zSteps][numImages];	int direction = 0;	ImageIcon[] zImages = images[0];			Point imageCenter = new Point(200,200);	Point destination = new Point(200,200);	Point size = new Point(81,81);	public static void main(String args[])	{		new Poochville();	}		public Poochville()	{		frame = new JFrame();		frame.setSize(500, 500);		frame.getContentPane().setBackground( new Color(60,60,60) );		frame.setVisible(true);				// dog images at various directions and sizes		loadImages();				// dog image shown via JLabel icon		label = new JLabel();		label.setIcon(images[0][0]);			label.setBounds(imageCenter.x-(size.x/2),imageCenter.y-(size.y/2),size.x,size.y); 		frame.getContentPane().add(label);				// clicking or click-drag will set a point the dog should move towards		frame.addMouseListener( new MouseAdapter() {    		public void mouseClicked(MouseEvent e)    		{	     		handleMoseEvent(e);	    	}    	} );				frame.addMouseMotionListener( new MouseMotionAdapter() {    		public void mouseDragged(MouseEvent e)    		{	     		handleMoseEvent(e);	    	}    	} );    			// Swing is not thread safe		// animation is typically done via swing timers which execute in the single swing thread		// that thread also executes the mouse listeners		// we will have a single timer for moving the dog towards its destination		Timer t = new Timer(100, new ScaledByDistanceMover()); 		t.start();		}		void loadImages()	{		for ( int i=1; i<=numImages; i++ )		{			String file = imageFilePrefix + i + imageFileSuffix;			images[0][i-1] = new ImageIcon(file);			for ( int z=1; z<zSteps; z++ )			{				float scaling = 1.0f + ( ( (float) z / zSteps ) );				int x = Math.round ( size.x / scaling );				int y = Math.round ( size.y / scaling );				images[z][i-1] = new ImageIcon(images[0][i-1].getImage().getScaledInstance(x,y,Image.SCALE_DEFAULT));			}		}	}		int directionToPoint(int x, int y)	{ 		x -= imageCenter.x; 		y -= imageCenter.y; 		double theta = ( ( Math.atan2 ( x,y ) * 4 ) / Math.PI ) + 4.5; 		int index = (int) Math.round( Math.floor(theta) ); 		index = ( (index + 4 ) % 8); 		return index;	}		void handleMoseEvent(MouseEvent e)	{		destination.x = e.getX();		destination.y = e.getY();				// dog should point towards it's destination		direction = directionToPoint(destination.x, destination.y);				label.setIcon(zImages[direction]);	}		abstract class Mover implements ActionListener	{		public void actionPerformed(ActionEvent evt)		{			// dog will move towards its destination some amount			Point distance = new Point();			distance.x = destination.x - imageCenter.x;			distance.y = destination.y - imageCenter.y;						if ( distance.x==0 && distance.y==0 ) return;						Point movement = new Point();			calculateMovement(distance,movement);									imageCenter.x += movement.x;			imageCenter.y += movement.y;			int x = imageCenter.x - (size.x/2);			int y = imageCenter.y - (size.y/2);			label.setBounds( x, y, size.x, size.y );			System.out.println( "x=" + x + ", y=" + y);						// dog will scale since it's movement plane is inclined from the display						int z = ( ( frame.getSize().height - imageCenter.y )  * zSteps ) / (frame.getSize().height + 1) ;			if (z<0) z = 0;			if (z>=zSteps) z = zSteps-1;			zImages = images[z];			label.setIcon( zImages [direction] );		}				abstract protected void calculateMovement (final Point distance, Point movement);	}		class ScaledByDistanceMover extends Mover	{		int moveByDistanceScale = 10;				protected void calculateMovement(final Point distance, Point movement)		{						// move 1/N the distance			movement.x = (int) Math.round ( ((double) distance.x) / moveByDistanceScale );			movement.y = (int) Math.round ( ((double) distance.y) / moveByDistanceScale );						// if either axis 1/N is < 1 it would be zero movement and we never get to the destination			// so move at least 1 on each axis that we need to go still			if (movement.x==0 && distance.x!=0) movement.x=distance.x;			if (movement.x==0 && distance.y!=0) movement.x=distance.y;		}	}		class ConstantVelocity extends Mover	{		protected void calculateMovement(final Point distance, Point movement)		{			// total distance l = sqrt (dx^2 + dy^2)			// constant velocity v = dl/dt			// dt is time between movement events			// dl is movement per event, mx,my are components of dl (dl^2 = mx^2+my^2)			// have to keep dx/dy = mx/my but avoid infinities			// problematic for integer coordinates...floats or sub-pixel at some resolution?			//double dist = Math.sqrt ( (dx * dx) + dy * dy );								//int mx =  (int) Math.round ( dx / dist );			//int my =  (int) Math.round ( dy / dist );						throw new RuntimeException("Constant velocity movement not implemented yet");		}	}	}