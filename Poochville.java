/*	Simple Swing based interactive dog	Click and it will move to that point	Drag and it will follow		This is very much a work in progress!		Dog is moving on a surface that is inclined from the screen so it get's smaller "front to back"	bottom of frame is closer than top		Uses a set of image files for dog facing at angles around the circle	Loads those in and generates scaled versions		Next steps:	- Move subclasses to their own file	- GUI component to switch between mover types	- GUI components to control mover subclass specific params	- Public getters and setters for  mover subclass specific params*/import java.awt.Color;import java.awt.Point;import java.awt.Image;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseAdapter;import java.awt.event.MouseMotionAdapter;import java.awt.event.MouseEvent;import java.awt.geom.Point2D;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.ImageIcon;import javax.swing.Timer;public class Poochville{	JFrame frame = null;	JLabel label = null;		String imageFilePrefix = "FooDog";	String imageFileSuffix = ".GIF";	int numImages = 8;		int zSteps = 100;		ImageIcon[][] images = new ImageIcon[zSteps][numImages];	int direction = 0;	ImageIcon[] zImages = images[0];			Point2D.Float imageCenter = new Point2D.Float(200,200);	Point2D.Float destination = new Point2D.Float(200,200);	Point size = new Point(81,81);		int movementInterval = 25;  // milliseconds	Timer movementTimer = null;	public static void main(String args[])	{		new Poochville();	}		public Poochville()	{		frame = new JFrame();		frame.setSize(500, 500);		frame.getContentPane().setBackground( new Color(60,60,60) );		frame.setVisible(true);				// can't animate the dog if a layout manager is present, it will force the position		frame.getContentPane().setLayout(null);				// on screen info for the user		JLabel infoText = new JLabel();		infoText.setText("click or click-drag ");		infoText.setLocation(10,10);		infoText.setSize(200, 20);		frame.add(infoText);		infoText.repaint();				// dog images at various directions and sizes		loadImages();				// dog image shown via JLabel icon		label = new JLabel();		label.setIcon(images[0][0]);			label.setLocation( (int) imageCenter.x-(size.x/2), (int) imageCenter.y-(size.y/2) );		label.setSize(size.x,size.y); 		frame.getContentPane().add(label);		label.repaint();				// clicking or click-drag will set a point the dog should move towards		frame.getContentPane().addMouseListener( new MouseAdapter() {    		public void mouseClicked(MouseEvent e)    		{	     		handleMoseEvent(e);	    	}    	} );				frame.getContentPane().addMouseMotionListener( new MouseMotionAdapter() {    		public void mouseDragged(MouseEvent e)    		{	     		handleMoseEvent(e);	    	}    	} );    			// Swing is not thread safe		// animation is typically done via swing timers which execute in the single swing thread		// that thread also executes the mouse listeners		// we will have a single timer for moving the dog towards its destination		Timer t = new Timer(movementInterval, new ScaledByDistanceMover()); 		t.start();		}		void loadImages()	{		for ( int i=1; i<=numImages; i++ )		{			String file = imageFilePrefix + i + imageFileSuffix;			images[0][i-1] = new ImageIcon(file);			for ( int z=1; z<zSteps; z++ )			{				float scaling = 1.0f + ( ( (float) z / zSteps ) );				int x = Math.round ( size.x / scaling );				int y = Math.round ( size.y / scaling );				images[z][i-1] = new ImageIcon(images[0][i-1].getImage().getScaledInstance(x,y,Image.SCALE_DEFAULT));			}		}	}		void handleMoseEvent(MouseEvent e)	{		destination.x = e.getX();		destination.y = e.getY();				// dog should point towards it's destination		direction = calcDirectionTo( (int) destination.x, (int) destination.y );				label.setIcon(zImages[direction]);	}		int calcDirectionTo(int x, int y)	{ 		x -= (int) imageCenter.x; 		y -= (int) imageCenter.y; 		double theta = ( ( Math.atan2 ( x,y ) * 4 ) / Math.PI ) + 4.5; 		int index = (int) Math.round( Math.floor(theta) ); 		index = ( (index + 4 ) % 8); 		return index;	}		abstract class Mover implements ActionListener	{		public void actionPerformed(ActionEvent evt)		{			// dog will move towards its destination some amount			Point2D.Float distance = new Point2D.Float();			distance.x = destination.x - imageCenter.x;			distance.y = destination.y - imageCenter.y;						if ( distance.x==0 && distance.y==0 ) return;						Point2D.Float movement = new Point2D.Float();			calculateMovement(distance,movement);									imageCenter.x += movement.x;			imageCenter.y += movement.y;			int x = (int) imageCenter.x - (size.x/2);			int y = (int) imageCenter.y - (size.y/2);			label.setLocation(x, y);						// dog will scale since it's movement plane is inclined from the display						int z = ( ( frame.getSize().height - (int) imageCenter.y )  * zSteps ) / (frame.getSize().height + 1) ;			if (z<0) z = 0;			if (z>=zSteps) z = zSteps-1;			zImages = images[z];			label.setIcon( zImages [direction] );		}				abstract protected void calculateMovement (final Point2D.Float distance, Point2D.Float movement);	}		class ScaledByDistanceMover extends Mover	{		int moveByDistanceScale = 10;				protected void calculateMovement(final Point2D.Float distance, Point2D.Float movement)		{						// move 1/N the distance			movement.x = distance.x / moveByDistanceScale ;			movement.y = distance.y / moveByDistanceScale ;		}	}		class ConstantVelocityMover extends Mover	{		double dl = 10; //movement interval				protected void calculateMovement(final Point2D.Float distance, Point2D.Float movement)		{			// total distance l = sqrt (dx^2 + dy^2)			// constant velocity v = dl/dt			// dt is time between movement events			// dl is movement per event, mx,my are components of dl (dl^2 = mx^2+my^2)			// lx = l * cos(theta)			// mx = dl * cos(theta)			// mx = dl * lx/l						double l = Math.sqrt( (distance.x*distance.x) + (distance.y*distance.y) );			if (l>dl)			{				movement.x = (float) (dl * distance.x / l);				movement.y = (float) (dl * distance.y / l);			}			else			{				movement.x = distance.x;				movement.y = distance.y;			}		}	}	}