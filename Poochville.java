/*	Simple Swing based interactive dog	Click and it will move to that point	Drag and it will follow		It's moving on a surface that is inclined from the screen so it get's smaller "front to back"	bottom of frame is closer than top		Uses a set of image files for dog facing at angles around the circle	Load those in and generate scaled versions*/import java.awt.Color;import java.awt.Point;import java.awt.Image;import java.awt.event.MouseAdapter;import java.awt.event.MouseMotionAdapter;import java.awt.event.MouseEvent;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.ImageIcon;public class Poochville{	JFrame frame = null;	JLabel label = null;		String imageFilePrefix = "FooDog";	String imageFileSuffix = ".GIF";	int numImages = 8;		int zSteps = 10;		ImageIcon[][] images = new ImageIcon[zSteps][numImages];	int image = 0;	ImageIcon[] ims = images[0];			Point imageCenter = new Point(200,200);	Point destination = new Point(200,200);	Point size = new Point(81,81);	public static void main(String args[])	{		new Poochville();	}		public Poochville()	{		frame = new JFrame();		frame.setSize(500, 500);		frame.getContentPane().setBackground( new Color(60,60,60) );		frame.setVisible(true);				loadImages();				label = new JLabel();		label.setIcon(images[0][image]);			label.setBounds(imageCenter.x-(size.x/2),imageCenter.y-(size.y/2),size.x,size.y); 		frame.getContentPane().add(label);				frame.addMouseListener( new MouseAdapter() {    		public void mouseClicked(MouseEvent e)    		{	     		imageMouseEvent(e);	    	}    	} );				frame.addMouseMotionListener( new MouseMotionAdapter() {    		public void mouseDragged(MouseEvent e)    		{	     		imageMouseEvent(e);	    	}    	} );    			Thread mover = new MoverThread();		mover.start();			}		void loadImages()	{		for ( int i=1; i<=numImages; i++ )		{			String file = imageFilePrefix + i + imageFileSuffix;			images[0][i-1] = new ImageIcon(file);			for ( int z=1; z<zSteps; z++ )			{				float scaling = 1.0f + ( ( (float) z / zSteps ) );				int x = Math.round ( size.x / scaling );				int y = Math.round ( size.y / scaling );				images[z][i-1] = new ImageIcon( images[0][i-1].getImage().getScaledInstance(x,y,Image.SCALE_DEFAULT));			}		}	}		int pointToImageNum ( int x, int y )	{ 		x -= imageCenter.x; 		y -= imageCenter.y; 		double theta = ( ( Math.atan2 ( x,y ) * 4 ) / Math.PI ) + 4.5; 		int index = (int) Math.round ( Math.floor(theta) ); 		index = ( (index + 4 ) % 8); 		return index;	}		void imageMouseEvent ( MouseEvent e )	{		image = pointToImageNum(e.getX(),e.getY());				label.setIcon( ims [image] );		destination.x = e.getX();		destination.y = e.getY();	}		class MoverThread extends Thread	{		public void run()		{			while (true)			{				int dx = destination.x - imageCenter.x;				int dy = destination.y - imageCenter.y;								// total distance is sqrt (dx^2 + dy^2)				// for constant velocity dl/dt, need  mx^2 + my^2 = dl^2				// have to keep ratio of dx/dy = mx/my, but avoid infinities				// (mx/my)^2 + 1 = (dl/my)^2				// (dx/dy)^2 + 1 = (dl/my)^2				// dl/my = sqrt( (dx/dy)^2 + 1)				// my = dl / sqrt( (dx/dy)^2 + 1)								// easier to just scale for distance...from L to dl				// L = sqrt (dx^2 + dy^2)				// dl = sqrt (mx^2 + my^2)				// mx = dx * (dl / L)				// my = dy * (dl / L)								// but if constrained to a grid, and only allow mx = 1,0, or -1,				// likewise for simpler choice...just sign of dx and dy, or zero								if ( dx!=0 && dy!=0 )				{					int mx = (int) Math.round ( ((double) dx) / 10 );					int my = (int) Math.round ( ((double) dy) / 10 );										double dist = Math.sqrt ( (dx * dx) + dy * dy );										//int mx =  (int) Math.round ( dx / dist );					//int my =  (int) Math.round ( dy / dist );										System.out.println( dx + " " + dy + " " + dist + " " + mx + " " + my );										imageCenter.x += mx;					imageCenter.y += my;					int x = imageCenter.x - (size.x/2);					int y = imageCenter.y - (size.y/2);					label.setBounds( x, y, size.x, size.y );										int imageZ = ( ( frame.getSize().height - imageCenter.y )  * zSteps ) / (frame.getSize().height + 1) ;										if (imageZ<0) imageZ = 0;					if (imageZ>=zSteps) imageZ = zSteps-1;										ims = images[imageZ];										label.setIcon( ims [image] );				}								try { sleep(100); }				catch ( InterruptedException e ) {}			}		}	}}